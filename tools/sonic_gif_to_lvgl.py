#!/usr/bin/env python3
"""
Convert an animated Sonic GIF to LVGL 1-bit indexed C arrays (140x68), 12 frames.

Usage:
  python3 tools/sonic_gif_to_lvgl.py <input_gif_path> <output_c_path>

Notes:
  - Frames are sampled evenly across the GIF duration to 12 frames
  - Each frame is prepared as follows:
      * composited on white background
      * converted to grayscale
      * resized to fit 68x140 (contain) on a white canvas
      * converted to 1-bit with Floyd-Steinberg dithering
      * rotated 90 degrees clockwise to 140x68 as required by nice!view
  - Output names: sonic01 .. sonic12
  - LVGL format: LV_IMG_CF_INDEXED_1BIT with 2-color palette (configurable inversion)
"""

import sys
from pathlib import Path
from typing import List

try:
    from PIL import Image, ImageOps
except ImportError as exc:
    sys.stderr.write("Pillow is required. Install with: python3 -m pip install --user pillow\n")
    raise


TARGET_W = 140
TARGET_H = 68
ROW_BYTES = (TARGET_W + 7) // 8  # 18 bytes per row for 140 px


def extract_evenly_spaced_frames(img: Image.Image, num_frames: int) -> List[Image.Image]:
    # Coalesce frames to absolute frames
    frames: List[Image.Image] = []
    try:
        total = img.n_frames
    except Exception:
        total = 1
    if total <= 0:
        total = 1
    indices = [min(int(round(i * (total - 1) / (num_frames - 1))), total - 1) for i in range(num_frames)] if total > 1 else [0] * num_frames
    for idx in indices:
        img.seek(idx)
        frames.append(img.convert("RGBA"))
    return frames


def prepare_frame_to_bw_rotated(frame: Image.Image) -> Image.Image:
    # Composite on white (to remove transparency)
    if frame.mode != "RGBA":
        frame = frame.convert("RGBA")
    bg = Image.new("RGBA", frame.size, (255, 255, 255, 255))
    composited = Image.alpha_composite(bg, frame)
    # Grayscale
    gray = composited.convert("L")
    # Fit into 68x140 with aspect preserved (contain)
    canvas = Image.new("L", (68, 140), color=255)
    tmp = gray.copy()
    tmp.thumbnail((68, 140), Image.LANCZOS)
    # Center on canvas
    x = (68 - tmp.width) // 2
    y = (140 - tmp.height) // 2
    canvas.paste(tmp, (x, y))
    # Dither to 1-bit
    bw = canvas.convert("1", dither=Image.FLOYDSTEINBERG)
    # Rotate 90Â° clockwise to 140x68
    rotated = bw.transpose(Image.ROTATE_270)
    # Ensure target size
    if rotated.size != (TARGET_W, TARGET_H):
        rotated = rotated.resize((TARGET_W, TARGET_H), Image.NEAREST)
    return rotated


def pack_image_to_1bpp_bytes(img_1bit: Image.Image) -> bytes:
    assert img_1bit.mode == "1"
    w, h = img_1bit.size
    assert (w, h) == (TARGET_W, TARGET_H)
    out = bytearray()
    for y in range(h):
        bit = 7
        byte = 0
        for x in range(w):
            # PIL mode '1': 255 = white, 0 = black
            pixel = img_1bit.getpixel((x, y))
            bit_val = 1 if pixel == 255 else 0  # index 1 = white, index 0 = black
            byte |= (bit_val & 1) << bit
            bit -= 1
            if bit < 0:
                out.append(byte)
                bit = 7
                byte = 0
        if bit != 7:
            out.append(byte)
    return bytes(out)


def format_c_array_bytes(b: bytes, indent: str = "  ") -> str:
    parts = []
    line = []
    for i, val in enumerate(b):
        line.append(f"0x{val:02x}")
        # Wrap every 18 bytes (one row) to mirror source formatting
        if (i + 1) % ROW_BYTES == 0:
            parts.append(indent + ", ".join(line) + ", ")
            line = []
    if line:
        parts.append(indent + ", ".join(line) + ", ")
    return "\n".join(parts)


def generate_c_file(frames_bytes: List[bytes], out_path: Path) -> None:
    assert len(frames_bytes) == 12
    with out_path.open("w", encoding="utf-8") as f:
        f.write("/*\n * Auto-generated by tools/sonic_gif_to_lvgl.py\n * SPDX-License-Identifier: MIT\n */\n\n")
        f.write("#include <lvgl.h>\n\n")
        f.write("#ifndef LV_ATTRIBUTE_MEM_ALIGN\n#define LV_ATTRIBUTE_MEM_ALIGN\n#endif\n\n")
        for idx, data in enumerate(frames_bytes, start=1):
            name = f"sonic{idx:02d}"
            macro = f"LV_ATTRIBUTE_IMG_{name.upper()}"
            f.write(f"#ifndef {macro}\n#define {macro}\n#endif\n\n")
            f.write(f"const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST {macro} uint8_t {name}_map[] = {{\n")
            f.write("#if CONFIG_NICE_VIEW_WIDGET_INVERTED\n")
            f.write("        0xff, 0xff, 0xff, 0xff, /*Color of index 0*/\n")
            f.write("        0x00, 0x00, 0x00, 0xff, /*Color of index 1*/\n")
            f.write("#else\n")
            f.write("        0x00, 0x00, 0x00, 0xff, /*Color of index 0*/\n")
            f.write("        0xff, 0xff, 0xff, 0xff, /*Color of index 1*/\n")
            f.write("#endif\n\n")
            f.write(format_c_array_bytes(data))
            f.write("\n};\n\n")
            f.write(f"const lv_img_dsc_t {name} = {{\n")
            f.write("  .header.cf = LV_IMG_CF_INDEXED_1BIT,\n")
            f.write("  .header.always_zero = 0,\n")
            f.write("  .header.reserved = 0,\n")
            f.write(f"  .header.w = {TARGET_W},\n")
            f.write(f"  .header.h = {TARGET_H},\n")
            f.write(f"  .data_size = {8 + ROW_BYTES * TARGET_H},\n")
            f.write(f"  .data = {name}_map,\n")
            f.write("};\n\n\n")


def main() -> None:
    if len(sys.argv) != 3:
        sys.stderr.write("Usage: python3 tools/sonic_gif_to_lvgl.py <input_gif_path> <output_c_path>\n")
        sys.exit(2)
    input_gif = Path(sys.argv[1]).expanduser().resolve()
    output_c = Path(sys.argv[2]).expanduser().resolve()
    output_c.parent.mkdir(parents=True, exist_ok=True)

    if not input_gif.exists():
        sys.stderr.write(f"Input GIF not found: {input_gif}\n")
        sys.exit(1)

    img = Image.open(str(input_gif))
    frames = extract_evenly_spaced_frames(img, 12)
    prepped = [prepare_frame_to_bw_rotated(frm) for frm in frames]
    frames_bytes = [pack_image_to_1bpp_bytes(p) for p in prepped]
    generate_c_file(frames_bytes, output_c)
    print(f"Wrote {output_c}")


if __name__ == "__main__":
    main()


